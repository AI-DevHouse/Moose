Now let me draft the complete technical specification:

â— TECHNICAL SPECIFICATION: Phase 2.3/3.2 Orchestrator (Aider-based Execution Infrastructure)

  1. EXECUTIVE SUMMARY

  Objective: Build Aider-based execution infrastructure that bridges Work Orders from Manager to code application in the repository.

  Scope: Phase 2.3/3.2 consolidated - create the "Orchestrator" infrastructure layer (NOT an agent) that:
  - Polls work_orders table for pending approved Work Orders
  - Triggers Manager for routing decisions
  - Spins up Aider CLI to apply Proposer-generated code
  - Creates branches, commits, and Pull Requests
  - Reports results back to Work Orders

  Estimated effort: 5-7 hours (per session-state.md)

  Key constraint: Docker not currently installed - will use Node.js child_process to spawn Aider instances instead of containers initially. Containerization can be added later.

  ---
  2. ARCHITECTURE OVERVIEW

  2.1 Component Diagram

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ DIRECTOR                                                     â”‚
  â”‚ â†“ Writes Work Orders to database (status='pending')         â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â†“
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ ORCHESTRATOR SERVICE (NEW)                                  â”‚
  â”‚                                                              â”‚
  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
  â”‚ â”‚ 1. Work Order Poller                                    â”‚â”‚
  â”‚ â”‚    - Polls work_orders table every 10s                  â”‚â”‚
  â”‚ â”‚    - Finds status='pending' + approved_by_director=true â”‚â”‚
  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
  â”‚                          â†“                                   â”‚
  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
  â”‚ â”‚ 2. Manager Coordinator                                  â”‚â”‚
  â”‚ â”‚    - Transforms Work Order â†’ ManagerRoutingRequest     â”‚â”‚
  â”‚ â”‚    - Calls /api/manager for routing decision           â”‚â”‚
  â”‚ â”‚    - Gets selected_proposer (claude-sonnet-4 vs gpt)   â”‚â”‚
  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
  â”‚                          â†“                                   â”‚
  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
  â”‚ â”‚ 3. Proposer Executor                                    â”‚â”‚
  â”‚ â”‚    - Transforms Work Order â†’ ProposerRequest           â”‚â”‚
  â”‚ â”‚    - Calls /api/proposer-enhanced for code generation  â”‚â”‚
  â”‚ â”‚    - Receives generated code with diffs                â”‚â”‚
  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
  â”‚                          â†“                                   â”‚
  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
  â”‚ â”‚ 4. Aider Executor                                       â”‚â”‚
  â”‚ â”‚    - Spawns Aider CLI via child_process                â”‚â”‚
  â”‚ â”‚    - Creates feature branch: feature/wo-{id}-{slug}    â”‚â”‚
  â”‚ â”‚    - Passes Proposer code to Aider via --message-file  â”‚â”‚
  â”‚ â”‚    - Aider applies changes with git commits            â”‚â”‚
  â”‚ â”‚    - Captures stdout/stderr for feedback               â”‚â”‚
  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
  â”‚                          â†“                                   â”‚
  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
  â”‚ â”‚ 5. GitHub Integration                                   â”‚â”‚
  â”‚ â”‚    - Pushes branch to remote                            â”‚â”‚
  â”‚ â”‚    - Creates PR via gh CLI                              â”‚â”‚
  â”‚ â”‚    - Adds metadata (risk, cost, proposer, WO ID)       â”‚â”‚
  â”‚ â”‚    - Updates work_orders table with PR URL             â”‚â”‚
  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
  â”‚                          â†“                                   â”‚
  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
  â”‚ â”‚ 6. Result Tracker                                       â”‚â”‚
  â”‚ â”‚    - Updates work_orders.status                         â”‚â”‚
  â”‚ â”‚    - Writes github_events table                         â”‚â”‚
  â”‚ â”‚    - Writes outcome_vectors for learning                â”‚â”‚
  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  2.2 Data Flow

  work_orders (status='pending', approved_by_director=true)
      â†“
  Orchestrator polls
      â†“
  Transform to ManagerRoutingRequest:
  {
    work_order_id: string,
    task_description: string,
    complexity_score: number (computed from acceptance_criteria),
    context_requirements: string[] (from files_in_scope),
    approved_by_director: true
  }
      â†“
  POST /api/manager â†’ RoutingDecision
  {
    selected_proposer: "claude-sonnet-4-5",
    reason: string,
    routing_metadata: {...}
  }
      â†“
  Transform to ProposerRequest:
  {
    task_description: work_order.description,
    context: work_order.files_in_scope,
    expected_output_type: "code",
    security_context: (inferred from risk_level)
  }
      â†“
  POST /api/proposer-enhanced â†’ EnhancedProposerResponse
  {
    content: string (generated code),
    cost: number,
    proposer_used: string,
    ...
  }
      â†“
  Create Aider instruction file:
  You are implementing Work Order: {title}

  Description: {description}

  Acceptance Criteria:
  - {criterion 1}
  - {criterion 2}

  Files to modify:
  - {file 1}
  - {file 2}

  Generated code:
  {proposer content}

  Apply these changes to the repository.
      â†“
  Spawn Aider:
  $ aider --message-file /tmp/wo-{id}-instruction.txt \
          --model {selected_proposer} \
          --yes \
          --auto-commits \
          {files_in_scope}
      â†“
  Aider applies changes + commits
      â†“
  Create PR:
  $ gh pr create --title "WO-{id}: {title}" \
                 --body "{PR body with metadata}"
      â†“
  Update work_orders:
  {
    status: 'in_progress',
    github_pr_url: string,
    github_pr_number: number,
    github_branch: string,
    metadata: {...routing_metadata, execution_metadata}
  }

  ---
  3. FILE STRUCTURE

  src/lib/orchestrator/
  â”œâ”€â”€ orchestrator-service.ts          # Main service (singleton)
  â”œâ”€â”€ work-order-poller.ts             # Polls work_orders table
  â”œâ”€â”€ manager-coordinator.ts           # Calls Manager API
  â”œâ”€â”€ proposer-executor.ts             # Calls Proposer API
  â”œâ”€â”€ aider-executor.ts                # Spawns Aider CLI
  â”œâ”€â”€ github-integration.ts            # PR creation + metadata
  â”œâ”€â”€ result-tracker.ts                # Updates database
  â””â”€â”€ types.ts                         # Orchestrator-specific types

  src/app/api/orchestrator/
  â”œâ”€â”€ route.ts                         # GET status, POST start/stop polling
  â””â”€â”€ execute/route.ts                 # POST manually trigger WO execution

  docs/
  â””â”€â”€ orchestrator-implementation.md   # Implementation notes

  ---
  4. DETAILED COMPONENT SPECIFICATIONS

  4.1 Orchestrator Service (orchestrator-service.ts)

  Responsibilities:
  - Singleton service that coordinates all Orchestrator components
  - Manages polling lifecycle (start/stop)
  - Maintains execution queue
  - Prevents concurrent execution of same Work Order

  Key Methods:
  class OrchestratorService {
    private static instance: OrchestratorService;
    private pollingInterval: NodeJS.Timeout | null = null;
    private executingWorkOrders: Set<string> = new Set();

    static getInstance(): OrchestratorService;

    startPolling(intervalMs: number = 10000): void;
    stopPolling(): void;

    async executeWorkOrder(work_order_id: string): Promise<ExecutionResult>;

    getStatus(): {
      polling: boolean,
      executing_count: number,
      last_poll: string,
      errors: Error[]
    };
  }

  Dependencies:
  - WorkOrderPoller
  - ManagerCoordinator
  - ProposerExecutor
  - AiderExecutor
  - GitHubIntegration
  - ResultTracker

  ---
  4.2 Work Order Poller (work-order-poller.ts)

  Responsibilities:
  - Query Supabase for pending Work Orders
  - Filter for status='pending' AND approved_by_director=true
  - Return Work Orders ordered by created_at ASC (FIFO)
  - Implement basic rate limiting

  Query:
  SELECT *
  FROM work_orders
  WHERE status = 'pending'
    AND metadata->>'approved_by_director' = 'true'
  ORDER BY created_at ASC
  LIMIT 10;

  Key Methods:
  export async function pollPendingWorkOrders(): Promise<WorkOrder[]> {
    const supabase = createSupabaseServiceClient();

    const { data, error } = await supabase
      .from('work_orders')
      .select('*')
      .eq('status', 'pending')
      .eq('metadata->>approved_by_director', 'true')
      .order('created_at', { ascending: true })
      .limit(10);

    if (error) throw error;
    return data || [];
  }

  ---
  4.3 Manager Coordinator (manager-coordinator.ts)

  Responsibilities:
  - Transform Work Order â†’ ManagerRoutingRequest
  - Call /api/manager endpoint
  - Extract routing decision
  - Handle Manager errors (budget exceeded, etc.)

  Transformation Logic:
  export function transformWorkOrderToManagerRequest(
    wo: WorkOrder
  ): ManagerRoutingRequest {
    return {
      work_order_id: wo.id,
      task_description: wo.description,
      complexity_score: estimateComplexity(wo),
      context_requirements: wo.files_in_scope || [],
      approved_by_director: true
    };
  }

  function estimateComplexity(wo: WorkOrder): number {
    // Heuristic based on acceptance_criteria count, files_in_scope count
    const criteriaCount = wo.acceptance_criteria?.length || 1;
    const filesCount = wo.files_in_scope?.length || 1;

    // Simple formula: 0.1 per criterion + 0.1 per file, capped at 1.0
    return Math.min(criteriaCount * 0.1 + filesCount * 0.05, 1.0);
  }

  API Call:
  export async function getRoutingDecision(
    wo: WorkOrder
  ): Promise<RoutingDecision> {
    const request = transformWorkOrderToManagerRequest(wo);

    const response = await fetch('http://localhost:3000/api/manager', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(request)
    });

    if (!response.ok) {
      throw new Error(`Manager routing failed: ${response.statusText}`);
    }

    const data = await response.json();
    return data.routing_decision;
  }

  ---
  4.4 Proposer Executor (proposer-executor.ts)

  Responsibilities:
  - Transform Work Order â†’ ProposerRequest
  - Call /api/proposer-enhanced endpoint
  - Extract generated code
  - Handle Proposer errors (refinement failures, etc.)

  Transformation Logic:
  export function transformWorkOrderToProposerRequest(
    wo: WorkOrder
  ): ProposerRequest {
    return {
      task_description: buildEnhancedTaskDescription(wo),
      context: wo.files_in_scope || [],
      security_context: mapRiskToSecurityContext(wo.risk_level),
      expected_output_type: 'code',
      priority: 'medium'
    };
  }

  function buildEnhancedTaskDescription(wo: WorkOrder): string {
    return `
  Work Order: ${wo.title}

  Description:
  ${wo.description}

  Acceptance Criteria:
  ${wo.acceptance_criteria?.map((ac, i) => `${i + 1}. ${ac}`).join('\n')}

  Files to modify:
  ${wo.files_in_scope?.map(f => `- ${f}`).join('\n')}

  Please generate complete, deployable code that satisfies all acceptance criteria.
  `.trim();
  }

  function mapRiskToSecurityContext(risk_level: string): 'high' | 'medium' | 'low' {
    if (risk_level === 'high') return 'high';
    if (risk_level === 'medium') return 'medium';
    return 'low';
  }

  API Call:
  export async function generateCode(
    wo: WorkOrder
  ): Promise<EnhancedProposerResponse> {
    const request = transformWorkOrderToProposerRequest(wo);

    const response = await fetch('http://localhost:3000/api/proposer-enhanced', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(request)
    });

    if (!response.ok) {
      throw new Error(`Proposer execution failed: ${response.statusText}`);
    }

    const data = await response.json();
    return data.data; // Note: API returns { success, data }
  }

  ---
  4.5 Aider Executor (aider-executor.ts)

  Responsibilities:
  - Create Aider instruction file
  - Spawn Aider CLI process via child_process
  - Create feature branch
  - Capture stdout/stderr
  - Handle Aider errors and timeouts

  Prerequisites:
  # User must install Aider globally:
  pip install aider-chat

  # Verify installation:
  aider --version

  Instruction File Format:
  export function createAiderInstructionFile(
    wo: WorkOrder,
    proposerResponse: EnhancedProposerResponse
  ): string {
    const instruction = `
  Work Order ID: ${wo.id}
  Title: ${wo.title}

  Description:
  ${wo.description}

  Acceptance Criteria:
  ${wo.acceptance_criteria?.map((ac, i) => `${i + 1}. ${ac}`).join('\n')}

  Files to modify:
  ${wo.files_in_scope?.map(f => `- ${f}`).join('\n')}

  Generated code from ${proposerResponse.proposer_used}:

  ${proposerResponse.content}

  Instructions:
  1. Create/modify the files listed above
  2. Apply the generated code changes
  3. Ensure all acceptance criteria are met
  4. Commit changes with descriptive message
  `.trim();

    const tmpDir = os.tmpdir();
    const instructionPath = path.join(tmpDir, `wo-${wo.id}-instruction.txt`);
    fs.writeFileSync(instructionPath, instruction, 'utf-8');

    return instructionPath;
  }

  Branch Creation:
  function createFeatureBranch(wo: WorkOrder): string {
    const slug = wo.title
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .substring(0, 30);
    const branchName = `feature/wo-${wo.id}-${slug}`;

    execSync(`git checkout -b ${branchName}`, { cwd: process.cwd() });

    return branchName;
  }

  Aider Execution:
  export async function executeAider(
    wo: WorkOrder,
    proposerResponse: EnhancedProposerResponse,
    selectedProposer: string
  ): Promise<AiderResult> {
    // 1. Create instruction file
    const instructionPath = createAiderInstructionFile(wo, proposerResponse);

    // 2. Create feature branch
    const branchName = createFeatureBranch(wo);

    // 3. Build Aider command
    const files = wo.files_in_scope?.join(' ') || '';
    const modelMap = {
      'claude-sonnet-4-5': 'claude-3-5-sonnet-20241022',
      'gpt-4o-mini': 'gpt-4o-mini'
    };
    const aiderModel = modelMap[selectedProposer] || 'claude-3-5-sonnet-20241022';

    const command = `aider --message-file "${instructionPath}" --model ${aiderModel} --yes --auto-commits ${files}`;

    // 4. Spawn Aider process
    return new Promise((resolve, reject) => {
      const aiderProcess = spawn('aider', [
        '--message-file', instructionPath,
        '--model', aiderModel,
        '--yes',
        '--auto-commits',
        ...files.split(' ')
      ], {
        cwd: process.cwd(),
        env: {
          ...process.env,
          ANTHROPIC_API_KEY: process.env.ANTHROPIC_API_KEY,
          OPENAI_API_KEY: process.env.OPENAI_API_KEY
        },
        timeout: 300000 // 5 minutes
      });

      let stdout = '';
      let stderr = '';

      aiderProcess.stdout.on('data', (data) => {
        stdout += data.toString();
        console.log('[Aider]', data.toString());
      });

      aiderProcess.stderr.on('data', (data) => {
        stderr += data.toString();
        console.error('[Aider Error]', data.toString());
      });

      aiderProcess.on('close', (code) => {
        // Clean up instruction file
        fs.unlinkSync(instructionPath);

        if (code === 0) {
          resolve({
            success: true,
            branch_name: branchName,
            stdout,
            stderr
          });
        } else {
          reject(new Error(`Aider exited with code ${code}: ${stderr}`));
        }
      });

      aiderProcess.on('error', (error) => {
        fs.unlinkSync(instructionPath);
        reject(error);
      });
    });
  }

  ---
  4.6 GitHub Integration (github-integration.ts)

  Responsibilities:
  - Push feature branch to remote
  - Create Pull Request via gh CLI
  - Add PR metadata (risk, cost, proposer, WO ID)
  - Extract PR URL and number

  Prerequisites:
  # User must install GitHub CLI:
  # https://cli.github.com/

  # Authenticate:
  gh auth login

  Implementation:
  export async function pushBranchAndCreatePR(
    wo: WorkOrder,
    branchName: string,
    routingDecision: RoutingDecision,
    proposerResponse: EnhancedProposerResponse
  ): Promise<GitHubPRResult> {
    // 1. Push branch
    execSync(`git push -u origin ${branchName}`, { cwd: process.cwd() });

    // 2. Build PR title and body
    const prTitle = `WO-${wo.id}: ${wo.title}`;
    const prBody = buildPRBody(wo, routingDecision, proposerResponse);

    // 3. Create PR
    const prOutput = execSync(
      `gh pr create --title "${prTitle}" --body "${prBody}" --head ${branchName}`,
      { cwd: process.cwd(), encoding: 'utf-8' }
    );

    // 4. Extract PR URL from output
    const prUrl = prOutput.trim().split('\n').pop() || '';

    // 5. Get PR number
    const prNumber = await getPRNumber(branchName);

    return {
      pr_url: prUrl,
      pr_number: prNumber,
      branch_name: branchName
    };
  }

  function buildPRBody(
    wo: WorkOrder,
    routingDecision: RoutingDecision,
    proposerResponse: EnhancedProposerResponse
  ): string {
    return `
  ## Work Order: ${wo.id}

  **Risk Level:** ${wo.risk_level}
  **Proposer Used:** ${proposerResponse.proposer_used}
  **Complexity Score:** ${routingDecision.routing_metadata.complexity_score}
  **Cost:** $${proposerResponse.cost.toFixed(4)}
  **Hard Stop Required:** ${routingDecision.routing_metadata.hard_stop_required ? 'Yes' : 'No'}

  ## Description

  ${wo.description}

  ## Acceptance Criteria

  ${wo.acceptance_criteria?.map((ac, i) => `- [x] ${ac}`).join('\n')}

  ## Files Modified

  ${wo.files_in_scope?.map(f => `- \`${f}\``).join('\n')}

  ## Routing Decision

  **Reason:** ${routingDecision.reason}
  **Confidence:** ${routingDecision.confidence}

  ## Metadata

  \`\`\`json
  ${JSON.stringify({
    work_order_id: wo.id,
    routing_metadata: routingDecision.routing_metadata,
    proposer_metadata: {
      cost: proposerResponse.cost,
      token_usage: proposerResponse.token_usage,
      execution_time_ms: proposerResponse.execution_time_ms,
      refinement_metadata: proposerResponse.refinement_metadata
    }
  }, null, 2)}
  \`\`\`

  ---

  ğŸ¤– Generated with [Moose Mission Control](https://github.com/AI-DevHouse/Moose)
  `.trim();
  }

  async function getPRNumber(branchName: string): Promise<number> {
    const output = execSync(
      `gh pr list --head ${branchName} --json number --jq '.[0].number'`,
      { cwd: process.cwd(), encoding: 'utf-8' }
    );
    return parseInt(output.trim(), 10);
  }

  ---
  4.7 Result Tracker (result-tracker.ts)

  Responsibilities:
  - Update work_orders table with execution results
  - Write to github_events table
  - Write to outcome_vectors for learning
  - Handle both success and failure cases

  Success Case:
  export async function trackSuccessfulExecution(
    wo: WorkOrder,
    routingDecision: RoutingDecision,
    proposerResponse: EnhancedProposerResponse,
    aiderResult: AiderResult,
    prResult: GitHubPRResult
  ): Promise<void> {
    const supabase = createSupabaseServiceClient();

    // 1. Update work_orders
    await supabase
      .from('work_orders')
      .update({
        status: 'in_progress', // PR created, awaiting review/merge
        github_pr_url: prResult.pr_url,
        github_pr_number: prResult.pr_number,
        github_branch: prResult.branch_name,
        metadata: {
          ...wo.metadata,
          routing_decision: routingDecision,
          proposer_response: {
            proposer_used: proposerResponse.proposer_used,
            cost: proposerResponse.cost,
            token_usage: proposerResponse.token_usage,
            execution_time_ms: proposerResponse.execution_time_ms
          },
          aider_execution: {
            branch_name: aiderResult.branch_name,
            success: aiderResult.success
          },
          orchestrator_execution_at: new Date().toISOString()
        }
      })
      .eq('id', wo.id);

    // 2. Write to github_events
    await supabase
      .from('github_events')
      .insert({
        event_type: 'pull_request',
        action: 'opened',
        pr_number: prResult.pr_number,
        branch_name: prResult.branch_name,
        work_order_id: wo.id,
        metadata: {
          pr_url: prResult.pr_url,
          risk_level: wo.risk_level,
          proposer_used: proposerResponse.proposer_used,
          cost: proposerResponse.cost
        }
      });

    // 3. Write to outcome_vectors
    await supabase
      .from('outcome_vectors')
      .insert({
        agent_name: 'orchestrator',
        operation_type: 'work_order_execution',
        success: true,
        execution_time_ms: proposerResponse.execution_time_ms,
        cost: proposerResponse.cost,
        metadata: {
          work_order_id: wo.id,
          proposer_used: proposerResponse.proposer_used,
          complexity_score: routingDecision.routing_metadata.complexity_score,
          hard_stop_required: routingDecision.routing_metadata.hard_stop_required
        }
      });
  }

  Failure Case:
  export async function trackFailedExecution(
    wo: WorkOrder,
    error: Error,
    stage: 'routing' | 'proposer' | 'aider' | 'github'
  ): Promise<void> {
    const supabase = createSupabaseServiceClient();

    // 1. Update work_orders
    await supabase
      .from('work_orders')
      .update({
        status: 'failed',
        metadata: {
          ...wo.metadata,
          orchestrator_error: {
            stage,
            message: error.message,
            timestamp: new Date().toISOString()
          }
        }
      })
      .eq('id', wo.id);

    // 2. Write to outcome_vectors
    await supabase
      .from('outcome_vectors')
      .insert({
        agent_name: 'orchestrator',
        operation_type: 'work_order_execution',
        success: false,
        metadata: {
          work_order_id: wo.id,
          error_stage: stage,
          error_message: error.message
        }
      });

    // 3. TODO: Trigger Client Manager escalation (Phase 2.X)
    console.error(`Work Order ${wo.id} failed at ${stage}:`, error);
  }

  ---
  5. API ENDPOINTS

  5.1 GET /api/orchestrator

  Purpose: Get Orchestrator status

  Response:
  {
    success: true,
    status: {
      polling: boolean,
      interval_ms: number,
      executing_count: number,
      executing_work_orders: string[],
      last_poll: string,
      total_executed: number,
      total_failed: number,
      errors: Array<{ message: string, timestamp: string }>
    }
  }

  5.2 POST /api/orchestrator/start

  Purpose: Start polling for Work Orders

  Request:
  {
    interval_ms?: number // Default 10000
  }

  Response:
  {
    success: true,
    message: "Orchestrator polling started",
    interval_ms: 10000
  }

  5.3 POST /api/orchestrator/stop

  Purpose: Stop polling

  Response:
  {
    success: true,
    message: "Orchestrator polling stopped"
  }

  5.4 POST /api/orchestrator/execute

  Purpose: Manually trigger execution of specific Work Order

  Request:
  {
    work_order_id: string
  }

  Response:
  {
    success: true,
    result: {
      work_order_id: string,
      pr_url: string,
      pr_number: number,
      branch_name: string,
      execution_time_ms: number
    }
  }

  ---
  6. CONFIGURATION

  6.1 Environment Variables (.env.local)

  # Existing
  ANTHROPIC_API_KEY=sk-ant-...
  OPENAI_API_KEY=sk-...
  NEXT_PUBLIC_SUPABASE_URL=https://...
  NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJ...
  SUPABASE_SERVICE_ROLE_KEY=eyJ...

  # New for Orchestrator
  ORCHESTRATOR_POLLING_INTERVAL_MS=10000
  ORCHESTRATOR_MAX_CONCURRENT_EXECUTIONS=3
  ORCHESTRATOR_AIDER_TIMEOUT_MS=300000
  ORCHESTRATOR_AUTO_START=false

  6.2 System Config Table

  Add to system_config table:
  INSERT INTO system_config (key, value, description) VALUES
  ('orchestrator_enabled', 'true', 'Enable Orchestrator polling'),
  ('orchestrator_polling_interval_ms', '10000', 'Polling interval in milliseconds'),
  ('orchestrator_max_concurrent', '3', 'Max concurrent Work Order executions');

  ---
  7. ERROR HANDLING

  7.1 Error Categories

  1. Manager Routing Errors
    - Budget exceeded (emergency_kill)
    - No available proposers
    - Invalid Work Order data
  2. Proposer Execution Errors
    - API timeout
    - Refinement failures
    - LLM API errors
  3. Aider Errors
    - Command not found (aider not installed)
    - Timeout (>5 minutes)
    - Git conflicts
    - Invalid file paths
  4. GitHub Errors
    - Authentication failures
    - Branch conflicts
    - PR creation failures

  7.2 Retry Strategy

  Aider failures â†’ Retry with same Proposer (attempt 2)
  Proposer failures â†’ Switch model via Manager retry strategy
  GitHub failures â†’ Retry push 1x, then fail

  7.3 Rollback Strategy

  If Aider fails:
  git checkout main
  git branch -D feature/wo-{id}-{slug}

  If PR creation fails:
  git push origin --delete feature/wo-{id}-{slug}
  git checkout main
  git branch -D feature/wo-{id}-{slug}

  ---
  8. TESTING STRATEGY

  8.1 Unit Tests

  - work-order-poller.test.ts - Query logic
  - manager-coordinator.test.ts - Transformation logic
  - proposer-executor.test.ts - API call mocking
  - aider-executor.test.ts - Command building (no actual exec)
  - github-integration.test.ts - PR body generation

  8.2 Integration Tests

  Add to phase1-2-integration-test.ps1:

  Test 19: Orchestrator Status
  $r = Invoke-RestMethod http://localhost:3000/api/orchestrator
  $r.success -eq $true -and $null -ne $r.status

  Test 20: Manual Work Order Execution (E2E)
  # Prerequisites:
  # 1. Aider installed: pip install aider-chat
  # 2. GitHub CLI authenticated: gh auth login
  # 3. Work Order exists in database with status='pending'

  $r = Invoke-RestMethod -Uri "http://localhost:3000/api/orchestrator/execute" `
    -Method POST `
    -ContentType "application/json" `
    -Body '{"work_order_id":"<test-wo-id>"}'

  $r.success -eq $true -and $null -ne $r.result.pr_url

  8.3 Manual E2E Test

  1. Create Work Order via Architect
  2. Approve via Director
  3. Verify Work Order in database (status='pending')
  4. Start Orchestrator polling: POST /api/orchestrator/start
  5. Wait 10 seconds
  6. Check Orchestrator status: GET /api/orchestrator
  7. Verify PR created on GitHub
  8. Verify Work Order status='in_progress'
  9. Stop polling: POST /api/orchestrator/stop

  ---
  9. DEPENDENCIES

  9.1 External Tools (User Must Install)

  # 1. Aider
  pip install aider-chat
  aider --version

  # 2. GitHub CLI
  # Windows: winget install --id GitHub.cli
  # Verify: gh --version
  gh auth login

  9.2 Node.js Packages

  {
    "dependencies": {
      // No new dependencies - use built-in child_process
    }
  }

  ---
  10. IMPLEMENTATION PHASES

  Phase 1: Core Infrastructure (2-3 hours)

  1. Create file structure
  2. Implement WorkOrderPoller
  3. Implement ManagerCoordinator
  4. Implement ProposerExecutor
  5. Implement OrchestratorService (without Aider)
  6. Add API endpoints

  Phase 2: Aider Integration (2-3 hours)

  1. Implement AiderExecutor
  2. Test Aider command execution locally
  3. Handle stdout/stderr capture
  4. Implement error handling and rollback

  Phase 3: GitHub Integration (1-2 hours)

  1. Implement GitHubIntegration
  2. Test branch creation and push
  3. Test PR creation with metadata
  4. Implement ResultTracker

  Phase 4: Testing & Polish (1 hour)

  1. Add integration tests
  2. Test E2E flow
  3. Update documentation
  4. Update session-state.md

  ---
  11. RISKS & MITIGATIONS

  | Risk                           | Impact | Mitigation                                                                |
  |--------------------------------|--------|---------------------------------------------------------------------------|
  | Aider not installed            | HIGH   | Check on startup, provide clear error message with install instructions   |
  | GitHub CLI not authenticated   | HIGH   | Verify gh auth status on startup                                          |
  | Concurrent executions conflict | MEDIUM | Use executingWorkOrders Set to prevent duplicates                         |
  | Aider timeout on large files   | MEDIUM | Set 5-minute timeout, log progress                                        |
  | Git merge conflicts            | MEDIUM | Aider's git-aware editing should prevent this, but add conflict detection |
  | API rate limits (LLM)          | MEDIUM | Respect Manager's budget enforcement                                      |
  | Polling overhead               | LOW    | 10-second interval is reasonable, can be adjusted                         |

  ---
  12. SUCCESS CRITERIA

  âœ… Work Orders transition from status='pending' to status='in_progress' automatically

  âœ… PRs created on GitHub with correct metadata (risk, cost, proposer, WO ID)

  âœ… Manager routing decisions respected (correct Proposer used)

  âœ… Aider successfully applies code changes with git commits

  âœ… Result tracking updates database correctly (work_orders, github_events, outcome_vectors)

  âœ… Integration tests: 20/20 passing (18 existing + 2 new Orchestrator tests)

  âœ… Zero regressions in existing tests

  âœ… Documentation complete and session-state.md updated

  ---
  13. OPEN QUESTIONS

  1. Should Orchestrator auto-start on server boot?
    - Proposal: No, require manual POST /api/orchestrator/start for safety
    - Add ORCHESTRATOR_AUTO_START=false env var for override
  2. How to handle Aider installation check?
    - Proposal: Check on first execution attempt, fail gracefully with install instructions
  3. Should we limit concurrent executions?
    - Proposal: Yes, max 3 concurrent Work Orders (configurable)
  4. What if Proposer generates code for wrong files?
    - Proposal: Trust Manager's routing + Proposer's output for now, Sentinel will validate later
  5. How to handle Work Orders with no files_in_scope?
    - Proposal: Fail with error "files_in_scope required" - Architect must specify files