Moose Agent Organizational Hierarchy & Responsibilities
FINAL CONSOLIDATED STRUCTURE (2025-09-29)
________________________________________
ARCHITECT (Phase 2.0 - NEW)
Purpose: Strategic decomposition of technical specifications into executable Work Orders
Responsibilities:
â€¢	Receive technical specification from human via Mission Control
â€¢	Analyze complexity, scope, and context requirements
â€¢	Estimate token/context limits per chunk to prevent agent memory overflow
â€¢	Map dependencies between components (what must be sequential vs parallelizable)
â€¢	Define Work Order boundaries (feature scope, file scope, risk-isolated changes)
â€¢	Create decomposition documentation: 
o	Dependency graph
o	Integration points
o	Chunking rationale
o	Sequencing requirements
â€¢	Output structured Work Orders with clear acceptance criteria
â€¢	Provide shared reference documentation to prevent context drift across agents
Key Outputs:
â€¢	Work Order queue with dependencies mapped
â€¢	Decomposition documentation accessible to all agents
â€¢	Context budget allocation per Work Order
â€¢	Integration contract specifications
Does NOT:
â€¢	Approve or assess risk (Director's job)
â€¢	Execute code generation (Proposer's job)
â€¢	Handle runtime coordination (Manager's job)
â€¢	Make escalation decisions (Client Manager's job)
â€¢	Apply code to repository (Orchestrator's job)
Database Tables:
â€¢	Writes to: work_orders (creates initial records)
â€¢	References: contracts (for boundary validation)
________________________________________
DIRECTOR (Phase 2.1) - Senior Governance
Purpose: Senior governance, risk assessment, and approval authority
Responsibilities:
â€¢	Receive Work Orders from Architect
â€¢	Validate against contracts using contract-validator.ts: 
o	Detect breaking changes
o	Verify API compatibility
o	Check domain model consistency
â€¢	Risk assessment per Work Order: 
o	Low: Config changes, documentation, non-breaking additions
o	Medium: Schema changes, new APIs, refactoring
o	High: Breaking changes, architecture modifications, security changes
â€¢	Decision logging with reasoning (full audit trail)
â€¢	Progressive trust system: 
o	Track pattern confidence scores
o	Auto-approve low-risk orders when confidence >0.95
o	Require human approval for medium/high risk
â€¢	Route high-risk Work Orders to human approval queue in Mission Control
â€¢	Hand approved Work Orders to Manager for execution coordination
â€¢	Monitor approval patterns to adjust trust thresholds
Key Outputs:
â€¢	Approved/rejected Work Orders with justification
â€¢	Risk classifications (Low/Medium/High)
â€¢	Decision audit trail with reasoning
â€¢	Approval workflow state changes
Does NOT:
â€¢	Decompose technical specs (Architect's job)
â€¢	Generate code (Proposer's job)
â€¢	Handle escalations (Client Manager's job)
â€¢	Coordinate runtime execution (Manager's job)
â€¢	Route to specific Proposers (Manager's job)
â€¢	Apply code changes (Orchestrator's job)
Database Tables:
â€¢	Reads: work_orders, contracts, pattern_confidence_scores
â€¢	Writes: decision_logs, updates work_orders.status
â€¢	References: playbook_memory for trust patterns
Current Implementation: Exists as "Manager LLM" in Phase 2.1, needs role clarity update
________________________________________
MANAGER (Phase 4.1) - Tactical Coordination
Purpose: Tactical runtime coordination and resource management
Responsibilities:
â€¢	Receive approved Work Orders from Director
â€¢	Context-aware routing to appropriate Proposer based on: 
o	Complexity analysis (7 factors)
o	Historical success patterns (outcome_vectors)
o	Current budget constraints (system_config)
o	Proposer availability and capability (proposer_configs)
o	Hard Stop keyword detection (security/architecture)
â€¢	Predictive resource allocation: 
o	Estimate token usage from historical data
o	Predict execution time
o	Forecast cost per Work Order
â€¢	Budget enforcement (three-tier system): 
o	Soft cap ($20 daily default): Alert Client Manager, continue
o	Hard cap ($50 daily): Force cheapest model (gpt-4o-mini)
o	Emergency kill ($100 daily): Stop all operations, escalate
o	Hard Stop override: security/architecture forces claude-sonnet-4 even if over budget
â€¢	Retry ladder with pattern-aware re-prompting: 
o	Attempt 1: Standard prompt
o	Attempt 2: Add failure context from attempt 1
o	Attempt 3: Switch model or escalate
â€¢	Real-time capacity management: 
o	Monitor concurrent Work Orders
o	Load balance across available Proposers
o	Queue orders when capacity constrained
â€¢	Track performance metrics per Proposer
Key Outputs:
â€¢	Routing decisions to Proposers (stored in routing_metadata)
â€¢	Retry strategies based on failure patterns
â€¢	Resource allocation adjustments
â€¢	Budget alerts and enforcement actions
â€¢	Performance analytics
Does NOT:
â€¢	Create or decompose Work Orders (Architect's job)
â€¢	Approve Work Orders (Director's job)
â€¢	Generate code (Proposer's job)
â€¢	Escalate to humans (Client Manager's job)
â€¢	Make risk assessments (Director's job)
â€¢	Apply code to repository (Orchestrator's job)
Database Tables:
â€¢	Reads: work_orders, proposer_configs, outcome_vectors, system_config, cost_tracking
â€¢	Writes: routing metadata to work_orders.metadata
â€¢	Queries: Daily cost totals from cost_tracking for budget enforcement
Current Implementation: Routing logic exists in Phase 2.2 (proposer-registry.ts), needs consolidation into Manager role
________________________________________
PROPOSERS (Phase 2.2) - Code Generation
Purpose: Code generation with quality self-refinement
Models in Registry:
Claude Sonnet 4.5 (Primary)
â€¢	Complexity threshold: 1.0 (handles all complexity levels)
â€¢	Cost: $3.00/1M input tokens, $15.00/1M output tokens
â€¢	Strengths: Complex logic, architecture, security, multi-step reasoning
â€¢	Use cases: Architecture changes, security fixes, complex integrations
â€¢	Hard Stop enforcement: Forced for security + architecture keywords
GPT-4o-mini (Fallback)
â€¢	Complexity threshold: 0.3 (simple tasks only)
â€¢	Cost: $0.15/1M input tokens, $0.60/1M output tokens
â€¢	Strengths: Simple CRUD, config changes, documentation, cost optimization
â€¢	Use cases: Low-complexity work, budget-constrained operations
Responsibilities:
â€¢	Receive routed Work Orders from Manager
â€¢	Complexity analysis using 7 factors: 
1.	Architectural impact: Changes to system structure
2.	Integration points: Number of systems/APIs affected
3.	Data transformations: Complex data manipulation required
4.	Error handling requirements: Exception scenarios to cover
5.	Testing complexity: Test cases needed
6.	Security implications: Auth, encryption, input validation
7.	Performance considerations: Scalability, optimization needs
â€¢	Generate complete, deployable code (not instructions - actual code)
â€¢	Self-refinement (Phase 2.2.6 - NEXT PHASE): 
o	Detect quality issues: 
ï‚§	TypeScript compilation errors
ï‚§	Contract violations
ï‚§	Logic inconsistencies
o	Regenerate with learned context from failures
o	Maximum 2-3 refinement attempts per Work Order
o	Feed successful refinement patterns to playbook_memory
o	Cost tracking per refinement cycle
â€¢	Parallel mode (Phase 2.2.7 - FUTURE): 
o	Medium-risk orders: claude-sonnet-4 and gpt-4o-mini compete
o	Orchestrator tests both outputs
o	Best solution (quality + cost) wins
â€¢	Cost tracking per generation + refinement attempts
â€¢	Hard Stop enforcement: 20 keywords force claude-sonnet-4: 
o	Security (12): SQL injection, XSS, CSRF, authentication, authorization, encryption, password hashing, API keys, secrets management, access control, input validation, sanitization
o	Architecture (8): API contract, schema change, breaking change, database migration, event schema, integration contract, system design, architectural decision
Key Outputs:
â€¢	Complete code with file paths and diffs
â€¢	Complexity analysis metadata (ComplexityAnalysis interface)
â€¢	Cost breakdown (per-token pricing)
â€¢	Refinement history (attempts, issues found, fixes applied)
â€¢	Routing justification (why this model was selected)
Does NOT:
â€¢	Decide routing (Manager's job)
â€¢	Apply code to repo (Orchestrator's job)
â€¢	Validate execution results (Sentinel's job via Orchestrator)
â€¢	Approve Work Orders (Director's job)
â€¢	Handle escalations (Client Manager's job)
Database Tables:
â€¢	Reads: work_orders, proposer_configs, playbook_memory
â€¢	Writes: cost_tracking, outcome_vectors, updates to work_orders.metadata
â€¢	Updates: pattern_confidence_scores after successful patterns
Current Implementation: Exists in Phase 2.2 with complexity routing, Hard Stops, budget gates operational. Self-refinement (2.2.6) is next phase.
________________________________________
ORCHESTRATOR (Phase 2.3/3.2 - CONSOLIDATED) - Execution Infrastructure
Purpose: Aider-based execution infrastructure that applies Proposer code to repository
NOT AN AGENT - This is infrastructure/tooling built on Aider CLI:
Components:
1.	GitHub Actions workflows (CI/CD orchestration)
2.	Aider CLI (git-aware code application engine)
3.	PR management scripts (metadata, auto-merge logic)
4.	Container infrastructure (ephemeral execution environments)
Responsibilities:
â€¢	Receive generated code from Proposers
â€¢	Spin up ephemeral Aider instances in containers: 
o	Isolated git environment per Work Order
o	Clean state (no cross-contamination)
o	Resource limits (CPU, memory, timeout)
â€¢	Apply code via Aider CLI: 
o	Aider receives Proposer's code/instructions
o	Makes git-aware edits to repository files
o	Validates changes can be applied cleanly
o	Reports conflicts or issues
â€¢	Live environment feedback via Aider: 
o	Check current file structure (what actually exists)
o	Verify imports resolve (dependencies available)
o	Test if code compiles (TypeScript/language checks)
o	Query actual state vs Proposer assumptions
o	Feed discrepancies back to Proposer for refinement
â€¢	Branch management: 
o	Create feature branches: feature/wo-[id]-[description]
o	Apply commits with descriptive messages
o	Push to remote repository
â€¢	Pull Request creation with enhanced metadata: 
o	Risk level (from Director)
o	Proposer used (model name)
o	Complexity score (0.0-1.0)
o	Work Order ID (traceability)
o	Cost tracking (dollars spent)
o	Hard Stop flag (if applicable)
â€¢	Trigger GitHub Actions workflows: 
o	Unit tests
o	Integration tests
o	Build validation
o	Linting/formatting checks
â€¢	Auto-merge logic for low-risk PRs: 
o	Wait for Sentinel approval (all checks pass)
o	Verify risk_level = "low"
o	Check pattern confidence >0.95
o	Execute merge if conditions met
â€¢	Rollback capability: 
o	Revert bundled changes on failure
o	Clean rollback without conflicts
o	Notify affected agents
â€¢	Collect and report execution results: 
o	Success/failure status
o	Test results
o	Build logs
o	Performance metrics
â€¢	Teardown ephemeral environments after completion
Aider-Specific Capabilities:
â€¢	Git-aware editing: Understands repo structure, makes targeted changes
â€¢	Live state queries: Can check what files exist, what imports are available
â€¢	Conflict detection: Identifies merge conflicts before they reach GitHub
â€¢	Atomic operations: Changes applied as coherent units
â€¢	Rollback support: Clean undo of changes if needed
Key Outputs:
â€¢	Feature branches (tracked in github_events)
â€¢	Pull requests with metadata (work_orders.github_pr_url)
â€¢	GitHub Actions triggers
â€¢	Deployment logs
â€¢	Test results for Sentinel
â€¢	Live environment reports (current state vs assumptions)
â€¢	Rollback operations when needed
Does NOT:
â€¢	Make approval decisions (Director's job)
â€¢	Generate code (Proposer's job)
â€¢	Evaluate quality (Sentinel's job - though Sentinel analyzes Orchestrator outputs)
â€¢	Route Work Orders (Manager's job)
â€¢	Handle escalations (Client Manager's job)
Database Tables:
â€¢	Reads: work_orders
â€¢	Writes: github_events, updates work_orders (github_pr_number, github_pr_url, github_branch)
â€¢	Writes: outcome_vectors (execution metrics)
Integration Points:
â€¢	Receives code from Proposers
â€¢	Spins up Aider CLI in containers
â€¢	Aider provides live feedback to Proposers (for refinement)
â€¢	Triggers GitHub Actions
â€¢	Reports results to Sentinel (via Actions outcomes)
â€¢	Notifies Client Manager on failures
Phase Consolidation: Combines Phase 2.3 (Basic Orchestrator) and Phase 3.2 (Aider Integration) into single unified execution infrastructure
________________________________________
SENTINEL (Phase 3.1) - Adaptive Quality Gates
Purpose: Adaptive quality gates with false-positive learning
Responsibilities:
â€¢	Parse GitHub Actions results from Orchestrator executions
â€¢	Interpret test outcomes (not just pass/fail binary): 
o	Pass: All tests passed
o	Fail: Real failures requiring attention
o	Flaky: Known intermittent failures (false positives)
â€¢	Adaptive thresholds based on historical baselines: 
o	Calculate Â±5% variance from outcome_vectors
o	Adjust pass thresholds per test suite
o	Account for environmental fluctuations
â€¢	False-positive pattern learning: 
o	Track tests with high flake rates (>10%)
o	Identify environmental issues (timeouts, race conditions)
o	Build ignore patterns for known false positives
o	Store patterns in pattern_confidence_scores
â€¢	Custom rule synthesis (project-specific quality rules): 
o	Learn from repeated failure patterns
o	Generate custom validation rules
o	Store in playbook_memory for reuse
â€¢	Severity drift detection: 
o	Monitor quality trends over time
o	Alert when quality degrades >10% from baseline
o	Trigger preventive escalations
â€¢	Concurrent validation streams: 
o	Handle multiple PRs in parallel
o	Isolate results per Work Order
o	Prevent cross-contamination
â€¢	Hard fail detection â†’ trigger Client Manager escalation: 
o	Repeated failures after retries
o	Critical test failures
o	Security/compliance violations
â€¢	Learn from human override decisions: 
o	Track when humans merge despite warnings
o	Adjust thresholds based on overrides
o	Reduce false-positive rate over time
Key Outputs:
â€¢	Pass/fail decisions per Work Order
â€¢	Quality metrics (test coverage, performance, security)
â€¢	False-positive patterns (stored for future reference)
â€¢	Escalation triggers to Client Manager
â€¢	Custom validation rules
â€¢	Quality trend reports
Does NOT:
â€¢	Generate code (Proposer's job)
â€¢	Create escalation options (Client Manager's job)
â€¢	Apply fixes (Orchestrator's job)
â€¢	Make approval decisions (Director's job)
â€¢	Route Work Orders (Manager's job)
Database Tables:
â€¢	Reads: github_events (Actions results), outcome_vectors (historical baselines)
â€¢	Writes: outcome_vectors (new execution results)
â€¢	Writes: pattern_confidence_scores (false-positive patterns)
â€¢	Writes: playbook_memory (custom rules)
â€¢	Triggers: escalations (on hard fails)
Integration Points:
â€¢	Receives GitHub Actions results via Orchestrator
â€¢	Analyzes test outcomes
â€¢	Notifies Orchestrator: approve auto-merge or block
â€¢	Escalates to Client Manager on hard failures
â€¢	Feeds learning patterns to playbook_memory
________________________________________
CLIENT MANAGER (Phase 2.X - NEW) - Human Interface
Purpose: Human interface for exception handling and escalations
Responsibilities:
â€¢	Monitor all agent execution states across the system: 
o	Watch work_orders table for stuck/failed states
o	Track escalations table for new entries
o	Monitor cost_tracking for budget anomalies
o	Observe pattern_confidence_scores for quality degradation
â€¢	Detect unresolvable issues: 
o	Proposer exhausts retries after self-refinement (2+ attempts failed)
o	Sentinel hard failures (repeated test failures, >3 cycles)
o	Budget overruns beyond delegated authority (approaching emergency_kill)
o	Conflicting requirements discovered mid-execution
o	Unforeseen technical blockers (dependencies unavailable, API changes)
o	Contract violations that can't be auto-resolved
o	Aider reports irreconcilable state (file conflicts, broken repo)
â€¢	Formulate resolution options (typically 2-4 alternatives): 
o	Option A: Retry with different approach (different model, different strategy)
o	Option B: Pivot technical solution (alternative architecture)
o	Option C: Amend earlier Work Orders (fix root cause upstream)
o	Option D: Abort and redesign (escalate to Architect for re-decomposition)
â€¢	Cost/risk/timeline analysis per option: 
o	Estimated additional cost
o	Success probability based on historical data
o	Time to resolution
o	Risk of compounding issues
â€¢	Generate recommendation with clear reasoning: 
o	Preferred option with justification
o	Trade-offs of each alternative
o	Confidence level in recommendation
â€¢	Present to human via Mission Control with full context: 
o	Failure history (all attempts + results)
o	Cost spent so far
o	Architect's original decomposition (for context)
o	Relevant logs and metrics
o	Visual timeline of escalation
â€¢	Execute human's decision: 
o	Amend Work Orders (update work_orders table)
o	Reallocate resources (change proposer_configs)
o	Trigger rollbacks (via Orchestrator)
o	Abort operations (mark work_orders as failed)
o	Request Architect re-decomposition
â€¢	Learn from human decisions: 
o	Store resolution patterns in escalation_scripts (hypothetical table)
o	Track which options humans prefer
o	Improve future recommendations
o	Identify automation opportunities (repeated manual interventions)
â€¢	Track intervention patterns: 
o	What categories of issues escalate most?
o	Which agents trigger escalations?
o	What resolution patterns succeed?
o	Where can automation reduce escalations?
Key Outputs:
â€¢	Escalation summaries with full context
â€¢	Option analysis (2-4 alternatives with cost/risk/time)
â€¢	Recommendations with reasoning and confidence level
â€¢	Decision execution confirmations
â€¢	Learning patterns for future escalations
â€¢	Intervention trend reports
Does NOT:
â€¢	Make final decisions on escalated issues (human's job - Client Manager only recommends)
â€¢	Generate code (Proposer's job)
â€¢	Decompose specs (Architect's job)
â€¢	Approve Work Orders (Director's job)
â€¢	Execute deployments (Orchestrator infrastructure)
â€¢	Evaluate test results (Sentinel's job)
Database Tables:
â€¢	Reads: All tables (needs full system visibility)
â€¢	Writes: escalations (creates escalation records)
â€¢	Writes: escalation_scripts (hypothetical - stores learned resolution patterns)
â€¢	Updates: work_orders.status when executing human decisions
â€¢	References: decision_logs, outcome_vectors, cost_tracking for context
User Interface:
â€¢	Mission Control escalation queue
â€¢	Real-time alerts for critical issues
â€¢	Option presentation with visual decision tree
â€¢	One-click decision execution
â€¢	Escalation history view
________________________________________
COMPLETE WORKFLOW HIERARCHY
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ HUMAN                                                         â”‚
â”‚ â€¢ Uploads technical specification                             â”‚
â”‚ â€¢ Reviews escalations from Client Manager (with options)      â”‚
â”‚ â€¢ Approves high-risk Work Orders from Director                â”‚
â”‚ â€¢ Makes final decisions on escalated issues                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ARCHITECT (Phase 2.0 - NOT YET IMPLEMENTED)                   â”‚
â”‚ Strategic Decomposition Agent                                 â”‚
â”‚ â€¢ Analyzes spec complexity & scope                            â”‚
â”‚ â€¢ Maps dependencies (sequential vs parallel)                  â”‚
â”‚ â€¢ Estimates context/token budgets per chunk                   â”‚
â”‚ â€¢ Creates Work Orders with acceptance criteria                â”‚
â”‚ â€¢ Outputs: WO queue + decomposition documentation             â”‚
â”‚                                                               â”‚
â”‚ CURRENT: Human manually creates Work Orders                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DIRECTOR (Phase 2.1 - IMPLEMENTED as "Manager LLM")           â”‚
â”‚ Senior Governance Agent                                       â”‚
â”‚ â€¢ Contract validation (breaking change detection)             â”‚
â”‚ â€¢ Risk assessment (Low/Medium/High)                           â”‚
â”‚ â€¢ Progressive trust auto-approval (confidence >0.95)          â”‚
â”‚ â€¢ High-risk â†’ human approval queue                            â”‚
â”‚ â€¢ Outputs: Approved WOs with risk classification              â”‚
â”‚                                                               â”‚
â”‚ FILES: src/lib/llm-service.ts, src/lib/contract-validator.ts â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MANAGER (Phase 4.1 - PARTIAL via proposer-registry.ts)        â”‚
â”‚ Tactical Coordination Agent                                   â”‚
â”‚ â€¢ Context-aware routing (complexity + keywords)               â”‚
â”‚ â€¢ Budget enforcement (soft $20/hard $50/emergency $100)       â”‚
â”‚ â€¢ Retry ladder with pattern-aware prompting                   â”‚
â”‚ â€¢ Capacity management & load balancing                        â”‚
â”‚ â€¢ Outputs: Routed WOs to appropriate Proposers                â”‚
â”‚                                                               â”‚
â”‚ FILES: src/lib/proposer-registry.ts, src/lib/config-services.tsâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PROPOSERS (Phase 2.2 - IMPLEMENTED)                           â”‚
â”‚ Code Generation Agents                                        â”‚
â”‚ â€¢ Claude Sonnet 4: complexity â‰¥1.0, all Hard Stops            â”‚
â”‚ â€¢ GPT-4o-mini: complexity <0.3, simple tasks                  â”‚
â”‚ â€¢ Complexity analysis (7 factors)                             â”‚
â”‚ â€¢ Self-refinement (Phase 2.2.6 - NEXT PHASE)                  â”‚
â”‚ â€¢ Hard Stop enforcement (20 security/architecture keywords)   â”‚
â”‚ â€¢ Outputs: Complete code with metadata                        â”‚
â”‚                                                               â”‚
â”‚ FILES: src/lib/enhanced-proposer-service.ts,                  â”‚
â”‚        src/lib/complexity-analyzer.ts,                        â”‚
â”‚        src/lib/claude-sonnet-proposer.ts                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ORCHESTRATOR (Phase 2.3/3.2 - NOT YET IMPLEMENTED)            â”‚
â”‚ Aider-based Execution Infrastructure (NOT an agent)           â”‚
â”‚ â€¢ Spins up ephemeral Aider containers                         â”‚
â”‚ â€¢ Aider applies code with git-aware editing                   â”‚
â”‚ â€¢ Aider queries live environment state                        â”‚
â”‚ â€¢ Aider feeds discrepancies back to Proposers                 â”‚
â”‚ â€¢ Creates branches: feature/wo-[id]-[description]             â”‚
â”‚ â€¢ Creates PRs with metadata (risk, proposer, cost)            â”‚
â”‚ â€¢ Triggers GitHub Actions                                     â”‚
â”‚ â€¢ Auto-merge low-risk after Sentinel pass                     â”‚
â”‚ â€¢ Outputs: Deployed code, test triggers, live feedback        â”‚
â”‚                                                               â”‚
â”‚ CURRENT: Manual git operations                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ GitHub Actions (CI/CD)                                        â”‚
â”‚ â€¢ Runs tests (unit, integration, E2E)                         â”‚
â”‚ â€¢ Executes builds                                             â”‚
â”‚ â€¢ Performs linting/formatting checks                          â”‚
â”‚ â€¢ Reports results                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SENTINEL (Phase 3.1 - NOT YET IMPLEMENTED)                    â”‚
â”‚ Adaptive Quality Gates Agent                                  â”‚
â”‚ â€¢ Parses GitHub Actions results                               â”‚
â”‚ â€¢ Adaptive thresholds (Â±5% historical baseline)               â”‚
â”‚ â€¢ False-positive learning (ignore flaky tests)                â”‚
â”‚ â€¢ Custom rule synthesis (project-specific rules)              â”‚
â”‚ â€¢ Hard fail â†’ escalate to Client Manager                      â”‚
â”‚ â€¢ Outputs: Pass/fail, quality metrics, escalation triggers    â”‚
â”‚                                                               â”‚
â”‚ CURRENT: Manual review of Actions results                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â†“
                   â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
                   â”‚  SUCCESS  â”‚  or  â”‚  FAILURE  â”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                                             â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CLIENT MANAGER (Phase 2.X - NOT YET IMPLEMENTED)              â”‚
â”‚ Human Interface Agent for Escalations                         â”‚
â”‚ â€¢ Monitors all agent states (detects unresolvable issues)     â”‚
â”‚ â€¢ Formulates 2-4 resolution options                           â”‚
â”‚ â€¢ Cost/risk/timeline analysis per option                      â”‚
â”‚ â€¢ Generates recommendation with reasoning                     â”‚
â”‚ â€¢ Presents to human via Mission Control                       â”‚
â”‚ â€¢ Executes human's decision                                   â”‚
â”‚ â€¢ Learns from interventions (reduces future escalations)      â”‚
â”‚                                                               â”‚
â”‚ CURRENT: Manual intervention via Mission Control UI           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â†“
                    Back to Human
________________________________________
FEEDBACK LOOPS & LEARNING
Self-Refinement Loop (Proposer â†” Orchestrator/Aider):
Proposer generates code
    â†“
Orchestrator/Aider applies + checks live state
    â†“
Discrepancy detected (missing import, wrong file path, etc.)
    â†“
Aider reports back to Proposer
    â†“
Proposer refines with live context (max 2-3 attempts)
    â†“
Success â†’ store pattern in playbook_memory
Quality Learning Loop (Sentinel â†’ System):
Sentinel detects false positive (flaky test)
    â†“
Pattern stored in pattern_confidence_scores
    â†“
Future executions ignore known flaky tests
    â†“
Reduces unnecessary escalations
Escalation Learning Loop (Client Manager â†’ System):
Issue escalated to human
    â†“
Human selects resolution option
    â†“
Client Manager stores decision pattern
    â†“
Similar future issues: Client Manager recommends proven solution
    â†“
Eventually: automate resolution (no escalation needed)
Budget Learning Loop (Manager â†’ Proposers):
Manager tracks cost per Work Order type
    â†“
Learns which tasks can use cheaper models
    â†“
Adjusts routing thresholds over time
    â†“
Reduces costs while maintaining quality
________________________________________
KEY ARCHITECTURAL PRINCIPLES
1.	Specialist Job Descriptions: Each agent has clear, non-overlapping responsibilities
2.	Context Isolation: Agents maintain only necessary context to prevent memory overflow
3.	Ephemeral Execution: Aider instances spun up/torn down per Work Order (no persistent state)
4.	Progressive Autonomy: Director auto-approves trusted patterns (confidence >0.95), escalates edge cases
5.	Learning Loops: All agents feed patterns to shared memory (playbook_memory, pattern_confidence_scores)
6.	Budget Enforcement: 3-tier system ($20 soft/$50 hard/$100 emergency) with graceful degradation
7.	Hard Stop Override: Security/architecture keywords force best model even over budget
8.	Human-in-the-Loop: Client Manager provides clear options + recommendations, never makes final decisions
9.	Live Feedback: Aider eliminates stale assumptions by querying actual environment state
10.	Adaptive Quality: Sentinel learns false positives and adjusts thresholds over time
________________________________________
CURRENT IMPLEMENTATION STATUS (v22)
âœ“ Completed (15/15 integration tests passing):
â€¢	Phase 1.1-1.3: Mission Control, Data Infrastructure, GitHub Integration
â€¢	Phase 2.1: Director (as "Manager LLM") - basic functionality
â€¢	Phase 2.2.1-2.2.5: Proposer Registry, routing, complexity analysis, Hard Stops
â€¢	Phase 2.2.8: Budget management (ConfigService, budget gates)
ğŸš€ Next Phase (Ready to Implement):
â€¢	Phase 2.2.6: Self-refinement within Work Order (Proposer quality loops)
â³ Pending Implementation:
â€¢	Phase 2.0: Architect agent (decomposition strategy)
â€¢	Phase 2.2.7: Parallel mode (Proposer competition)
â€¢	Phase 2.3/3.2: Orchestrator infrastructure (Aider-based execution)
â€¢	Phase 2.X: Client Manager agent (escalation handling)
â€¢	Phase 3.1: Sentinel (adaptive quality gates)
â€¢	Phase 4.1: Manager enhancements (tactical coordination - currently partial)
________________________________________
DATABASE SCHEMA SUPPORT
All agents integrate with Supabase tables:
â€¢	work_orders - Work Order lifecycle tracking
â€¢	contracts - API/domain contract validation
â€¢	proposer_configs - Model registry and capabilities
â€¢	decision_logs - Director approval audit trail
â€¢	cost_tracking - Budget monitoring and enforcement
â€¢	outcome_vectors - Historical performance metrics
â€¢	pattern_confidence_scores - Trust and learning patterns
â€¢	playbook_memory - Successful patterns and fixes
â€¢	escalations - Unresolved issues requiring human intervention
â€¢	github_events - Repository activity tracking
â€¢	system_config - Runtime configuration (budget limits, thresholds)
________________________________________
This document represents the complete agreed architectural structure for the Moose system with consolidated Orchestrator/Aider execution infrastructure (2025-09-29).

